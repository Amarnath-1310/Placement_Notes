CREATE DATABASE IndexDemo;
USE IndexDemo;

-- Create Sample Table
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,      -- automatically creates a clustered index
    FirstName NVARCHAR(50),
    LastName NVARCHAR(50),
    Department NVARCHAR(50),
    Salary INT
);


âœ… Create Clustered Index Explicitly

(If primary key is not there)
-- Drop primary key first if exists, then:

CREATE CLUSTERED INDEX IX_Employees_Dept
ON Employees(Department);


ðŸ‘‰ Now rows are physically sorted by Department.

âœ… Create Non-Clustered Index
CREATE NONCLUSTERED INDEX IX_Employees_Salary
ON Employees(Salary);


ðŸ‘‰ Helps when you run:

SELECT * FROM Employees WHERE Salary > 50000;

âœ… Drop Index
DROP INDEX IX_Employees_Salary ON Employees;
DROP INDEX IX_Employees_Dept ON Employees;

ðŸ”¹ Demo: Why Indexing Matters

Without Index
SELECT * FROM Employees WHERE Salary = 60000;
ðŸ‘‰ The database scans all rows (Table Scan). Slow when millions of rows exist.

With Non-Clustered Index on Salary
CREATE NONCLUSTERED INDEX IX_Employees_Salary
ON Employees(Salary);
ðŸ‘‰ The query will use index â†’ directly finds Salary = 60000 (Index Seek). Much faster ðŸš€.

ðŸ“Œ Quick Summary
Clustered Index â†’ sorts the table itself (1 per table).
Non-Clustered Index â†’ keeps a separate index (many allowed).
Advantages â†’ faster reads, efficient queries.
Disadvantages â†’ slower writes, extra storage.
Best Practice â†’ create indexes only on frequently searched columns.
